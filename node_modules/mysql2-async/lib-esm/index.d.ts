/// <reference types="node" />
/// <reference types="node" />
import mysql, { type Pool, type PoolConnection, type PoolOptions } from 'mysql2';
import type { Pool as PromisePool, PoolConnection as PromisePoolConnection } from 'mysql2/promise';
import { Readable } from 'stream';
export type Mysql2AsyncQueryLogger = (sql: string, elapsedMs: number, rowsUpdated: number) => void | Promise<void>;
export interface Mysql2AsyncOptions {
    logQueries?: Mysql2AsyncQueryLogger;
}
export interface DbConfig extends PoolOptions, Mysql2AsyncOptions {
    skiptzfix?: boolean;
}
export interface QueryOptions {
    saveAsPrepared?: boolean;
    nestTables?: true | '_';
    rowsAsArray?: boolean;
}
export interface StreamOptions extends QueryOptions {
    highWaterMark?: number;
}
interface canBeStringed {
    toString: () => string;
}
interface BindObject {
    [keys: string]: BindParam;
}
type BindParam = boolean | number | string | null | Date | Buffer | canBeStringed | BindObject;
type ColTypes = BindParam;
type BindInput = BindParam[] | BindObject;
interface StreamIterator<ReturnType> {
    [Symbol.asyncIterator]: () => StreamIterator<ReturnType>;
    next: () => Promise<{
        done?: false;
        value: ReturnType;
    }>;
    return: () => Promise<{
        done: true;
        value: ReturnType;
    }>;
}
interface GenericReadable<T> extends Readable {
    [Symbol.asyncIterator]: () => StreamIterator<T>;
}
export declare class Queryable {
    protected conn: PoolConnection | Pool;
    protected promiseConn: PromisePoolConnection | PromisePool;
    protected options: Mysql2AsyncOptions;
    constructor(conn: PoolConnection | Pool, options: Mysql2AsyncOptions);
    query(sql: string, binds?: BindInput, options?: QueryOptions): Promise<mysql.OkPacket | mysql.RowDataPacket[] | mysql.RowDataPacket[][] | mysql.OkPacket[] | mysql.ProcedureCallPacket | mysql.ResultSetHeader[]>;
    getval<ReturnType = ColTypes>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType | undefined>;
    getvals<ReturnType = ColTypes>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType[]>;
    getrow<ReturnType = any>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType | undefined>;
    getall<ReturnType = any>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType[]>;
    execute(sql: string, binds?: BindInput, options?: QueryOptions): Promise<boolean>;
    update(sql: string, binds?: BindInput, options?: QueryOptions): Promise<number>;
    delete(sql: string, binds?: BindInput, options?: QueryOptions): Promise<number>;
    insert(sql: string, binds?: BindInput, options?: QueryOptions): Promise<number>;
    protected feedStream<ReturnType>(stream: GenericReadable<ReturnType>, sql: string, binds: BindInput, options?: QueryOptions): void;
    protected handleStreamOptions<ReturnType>(sql: string, bindsOrOptions: any, options?: StreamOptions): {
        binds: any;
        queryOptions: QueryOptions;
        stream: GenericReadable<ReturnType>;
    };
    stream<ReturnType = any>(sql: string, options: StreamOptions): GenericReadable<ReturnType>;
    stream<ReturnType = any>(sql: string, binds?: BindInput, options?: StreamOptions): GenericReadable<ReturnType>;
    iterator<ReturnType = any>(sql: string, options: StreamOptions): StreamIterator<ReturnType>;
    iterator<ReturnType = any>(sql: string, binds?: BindInput, options?: StreamOptions): StreamIterator<ReturnType>;
    in(binds: BindInput, newbinds: BindParam[]): string;
}
export default class Db extends Queryable {
    protected pool: Pool;
    constructor(config?: DbConfig);
    logQueries(logger?: Mysql2AsyncQueryLogger): void;
    wait(): Promise<void>;
    transaction<ReturnType>(callback: (db: Queryable) => Promise<ReturnType>, options?: {
        retries?: number;
        retryPause?: number;
        lockForWrite?: string[] | string;
        lockForRead?: string[] | string;
        unlockAfter?: boolean;
    }): Promise<ReturnType>;
}
export {};
